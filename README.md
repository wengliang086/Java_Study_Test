# Java知识点测试记录（备忘）

## io

## net

* netty

* nio
    1. nio 比 bio 为什么少内存拷贝 ???

* redis
    ### 问题：
    1. 集群状态下，怎么保证多节点数据的同步（数据修改操作的同步） ???
        
        Redis的正常部署中一般都是一个master用于写操作，若干个slave用于读操作，另外定期的数据备份操作也是单独选址一个slave完成，这样可以最大程度发挥出redis的性能
    2. Redis 为什么使用单进程单线程方式也这么快
        1. 完全基于内存；
        2. 数据结构简单，对数据操作也简单；
        3. 使用多路 I/O 复用模型；
    3. 为什么Redis内存不宜过大
        
        在主库宕机的时候，我们最常见的容灾策略为“切主”。具体为从该集群剩余从库中选出一个从库并将其升级为主库，该从库升级为主库后再将剩余从库挂载至其下成为其从库，最终恢复整个主从集群结构。
        而代价最大的过程为从库的重新挂载，而非主库的切换。
        
        #### 解决办法(极力减少内存的使用)
        
            1. 设置过期时间
            2. 不存放垃圾到redis中
            3. 及时清理无用数据
            4. 大数据进行压缩
            5. 关注内存增长并定位大容量key
            6. pika
* udp

* zookeeper
    ### 问题：
    1. 集群状态下，怎么保证多节点数据的同步（数据修改操作的同步） ???
        
    2. 
    
    ### 主要的五种用途

    1. 命名服务
    
        在zookeeper的文件系统里创建一个目录，即有唯一的path。通过path即能互相探索发现。
    
    2. 配置管理
        
        Watcher 机制，类似触发器
        
    3. 集群管理
    
        所谓集群管理无在乎两点：是否有机器退出和加入、选举master。 
        * 对于第一点，所有机器约定在父目录GroupMembers下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除。
        * 新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount又有了，对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。
    
    4. 分布式锁
    
        锁服务可以分为两类，一个是保持独占，另一个是控制时序。
        
        * 对于第一类，我们将zookeeper上的一个znode看作是一把锁，通过createznode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的distribute_lock 节点就释放出锁。
        * 对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除，依次方便。
    
    5. 队列管理
    
        两种类型的队列：
        
        1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。 

        2、队列按照 FIFO 方式进行入队和出队操作。 
        
        第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。 
        
        第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。

## proxy

* cglib

* javassist

* jdk

## spi

## spring schema

## CAP理论
    ① C：Consistency，一致性，数据一致更新，所有数据变动都是同步的。
    ② A：Availability，可用性，系统具有好的响应性能。
    ③ P：Partition tolerance，分区容错性。以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择，也就是说无论任何消息丢失，系统都可用。
    该理论已被证明：任何分布式系统只可同时满足两点，无法三者兼顾。 因此，将精力浪费在思考如何设计能满足三者的完美系统上是愚钝的，应该根据应用场景进行适当取舍。
